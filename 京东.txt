及时止损
时间限制：C/C++语言 1000MS；其他语言 3000MS
内存限制：C/C++语言 65536KB；其他语言 589824KB
题目描述：
最近经济不景气，小A准备将持仓的股票抛售一部分，他共持有n支股票，受交易平台的限制，他每天最多只能卖出m支股票，已知第i支股票每天会亏损a_i元，即如果第k天抛售这支股票，亏损的数额是k*a_i元。
现在他还没有决定具体卖出多少支股票，所以他会给你若干个询问，即如果卖出q支股票，这q支股票最少的亏损数额是多少元。

输入
输入第一行包含两个正整数n和m，表示小A持仓的股票数量和每天最多能卖出的股票数量。(1<=n,m<=50000)
输入第二行包含n个正整数，第i个数a_i表示第i支股票每天的亏损数额。(1<=a_i<=10000)
接下来一行有一个正整数Q，表示询问的数量。(1<=Q<=50000)
之后有Q行，每行有一个正整数q，表示假如要卖出q支股票，最少的亏损数额是多少元。(q<=n)
输出
对于每个询问，输出对应的结果。
样例输入
5 2
1 2 3 4 5
2
3
5
样例输出
7
22
提示
样例解释：
一共有5支股票，每天最多可以抛售2支
q为2，即有两个询问
针对第一个询问3，需要抛售3支股票，当选择第1、2、3号股票时损失最小。其中第一天抛售2、3号股票，损失为5元；第二天抛售1号股票，损失为2*1=2元；最后合计损失为7元。
针对第二个询问5，需要抛售第1、2、3、4、5号股票。其中第一天抛售4、5号股票，损失为9元；第二天抛售2、3号股票，损失为2*2+2*3=10；第三天抛售1号股票，损失为3*1=3元；最后合计损失22元。

27%
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int main()
{
    int n,m,Q,q;
    cin>>n>>m;
    vector<int> v(n);
    for(int i = 0;i<n;i++)
        cin>>v[i];
    sort(v.begin(),v.end());
    cin>>Q;
    while(Q--)
    {
        cin>>q;
        int k = 1,sum = 0;
        while(q>m)
        {
            for(int i = 0;i<m;i++)
            {
                sum += v[q-1-i]*k;
            }
            k++;
            q -= m;
        }
        for(int i = q-1;i>=0;i--)
        {
            sum += v[i]*k;
        }
        cout<<sum<<endl;
    }
    return 0;
}


列车排座2
时间限制：C/C++语言 1000MS；其他语言 3000MS
内存限制：C/C++语言 65536KB；其他语言 589824KB
题目描述：
有n位乘客乘坐一列列车，列车一共会依次经过105个站点，从1到105编号。
我们已知每一位乘客的上车站点和下车站点，但是不知道这些乘客的订票顺序。
当一位乘客订票时，他会在当前还空余的座位中选择一个他喜欢的位置，但是我们不知道乘客的喜好，所有他具体订哪个位置我们是不知道的。
现在你需要计算列车最少需要安排多少座位，可以使得无论乘客的订票情况和顺序是怎么样的，所有乘客都有座位可以坐。
举个例子，有三位乘客：
A：1→2
B：2→3
C：1→3
若订票顺序是A, C, B，那么只需要两个座位就一定能满足。当A订票时，他会选择一个座位，当C订票时，可用座位只剩下一个，他会订这个剩余的座位，当B订票时，可用座位也只有一个，他会订这个座位(即最开始A的那个座位)；
若订票顺序是A, B, C，那么有可能会需要三个座位，A订了一个座位，B订了与A不同的座位，此时C来订票时他只能订第三个座位。
所以对于这组例子，答案是3。
输入
第一行包含一个整数n，表示乘客的数量。
1 <= n <= 1000
接下来n行每行包含两个整数si，ti，表示第i位乘客的上车站点和下车站点。
1 <= si < ti <= 105
输出
输出对应的答案。
样例输入
10
84 302
275 327
364 538
26 364
29 386
545 955
715 965
404 415
903 942
150 402
样例输出
6

22
#include <iostream>
#include <vector>
#include <map>
#include <numeric>
#include <limits>
#include<algorithm>

using namespace std;


/*请完成下面这个函数，实现题目要求的功能
当然，你也可以不按照下面这个模板来作答，完全按照自己的想法来 ^-^
******************************开始写代码******************************/
bool cmp(pair<int,int> X,pair<int,int> Y)
{
    if(X.first == Y.first)
        return X.second > Y.second;
    return X.first > Y.first;
}
int solve(int n, vector<int> &S, vector<int> &T) {
    int count = 1;
    vector< pair<int,int> > v(n);
    for(int i = 0;i<n;i++)
        v[i] = pair<int,int>(S[i],T[i]);
    sort(v.begin(),v.end(),cmp);
    for(int i = 0;i<n;i++)
    {
        int t = 0;
        for(int j = i;j<n;j++)
        {
            if(v[j].second <= v[i].first)
                t++;
        }
        if(t == 0)
            break;
        count++;
    }
	return count;
	//return n;//单这个也22
}
/******************************结束写代码******************************/


int main() {
    int n;
    cin >> n;
    vector<int> S, T;
    for (int i = 0; i < n; ++i) {
        int s, t;
        cin >> s >> t;
        S.push_back(s);
        T.push_back(t);
    }
    cout << solve(n, S, T) << endl;
    return 0;

}
