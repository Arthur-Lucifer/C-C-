题目描述 
系统中有一棵n个点的完全k叉树，现给出它的BFS层序遍历序列a_ia 
i
​	
 （即从根节点开始，每一层从左向右遍历），请你还原这棵树，并返回加密后的答案。
答案加密方法：所有边两个端点异或的和，即\sum\limits_{i=1}^{n-1}u_i\ xor\ v_i 
i=1
∑
n−1
​	
 u 
i
​	
  xor v 
i
​	
 ，其中(u_i, v_i)(u 
i
​	
 ,v 
i
​	
 )为一条树上的边。
下面给出完全二叉树的定义：若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k层所有的结点都连续集中在最左边。
请你根据这个定义进行适度推广，得到完全k叉树的含义。
示例1
输入
复制
2,[1,2,3,4,5]
返回值
复制
18
说明
树边为(1, 2), (1, 3), (2, 4), (2, 5)，加密过程为(1^2)+(1^3)+(2^4)+(2^5)，答案为18。
样例1构成的完全二叉树为：
示例2
输入
复制
3,[1,2,3,4,5]
返回值
复制
17
说明
树边为(1, 2), (1, 3), (1, 4), (2, 5)，加密过程为(1^2)+(1^3)+(1^4)+(2^5)，答案为17。
样例2构成的完全三叉树为：
备注:
数据满足：1\leq n,k\leq 10^5, 1\leq a_i\leq 10^91≤n,k≤10 
5
 ,1≤a 
i
​	
 ≤10 
9
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param k int整型 表示完全k叉树的叉数k
     * @param a int整型vector 表示这棵完全k叉树的Bfs遍历序列的结点编号
     * @return long长整型
     */
    long long tree2(int k, vector<int>& a) {
        // write code here
        long long res = 0;
        int n = a.size();
        for(int i = 0;i<n;i++)
        {
            for(int j = 1;j<=k;j++){
                if(i*k+j >= n){
                   return res;
                }
                res += a[i]^a[i*k+j];
            }
        }
        return res;
    }
};